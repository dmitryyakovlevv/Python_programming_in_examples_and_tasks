from flask import Flask, render_template, url_for, request, redirect  # из библиотеке flask импортируем класс Flask, функция render_template необходим для чтения html файлов, url_for в этом файле она не используется, но она необходима на всякий случай чтобы работали различные шаблоны в html файлах
from flask_sqlalchemy import SQLAlchemy  # из библиотеки flask_sqlalchemy импортируем класс SQLAlchemy
from datetime import datetime

app = Flask(__name__)  # на основе класса Flask необходимо создать объект и в конструктор необходимо передать название того файла, который будет являтся основнымтфайло, для этого используем директиву (__name__), которая передант сам файл, в котором мы все запускаем. то есть мы говорим, что app является осноным файлом для работы с этой библиотекой. при помощи объекта app мы имеем доступ к множеству различных функций из библиотеки flask
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///blog.db' #после создания объекта app (строчкой выше) мы обращаемся к словарю config и находим элемент по ключу (SQLALCHEMY_DATABASE_URI), и устанавливаем в этот элемент значение той базы данных, с которой мы будем работать после чего указываем :///blog.db это название базы данной с расширением db
db = SQLAlchemy(app)  #создаем объект db на основе класса SQLAlchemy, при моздании объекта в конструкторе необъодимо передовать объект, который создан на основе класса Flask (первая строчка), причем до этого важно, чтобы мы в этом объекте уже настроили подключение к нужной для нас базе данных (строчка выше)
app.config['SQLALCHEMY_TRACK_MO DIFICATIONS'] = False  # отключаем поддержку SQLALCHEMY_TRACK_MODIFICATIONS
db.init_app(app)


class Article(db.Model):  #создаем класс, который представляет из себя определенную табличку в базе данных. Т.е на нашем сайте мы будем хранить различные записи в определенной табличке, соответственно создаем класс и на основе этого класса мы можем создавать различные записи и каждая запись это будет определенная статья на нашем сайте, мы эти записи сможем сохранять в базе данных, удалять, редактировать, получать итд, ну и соответсвенно чтобы росто работать со всеми этими записями (проводить манипуляции) нам необходимо создать класс. создавая класс мы все наследуем от объекта db с помощью (db.Model). Внутри класса мы прописываем различнве поля и каждое поле будет отвечать за определенное поле в табличке. Например, для каждой статьи мы хоти установить такие вещи, как название, вступительный текст, основной текст и дата публикации, соответственно нужно 4 поля, но также нужно пятое и необходимое (обязательное) поле содержащее уникальный индетификатор каждой записи, то есть первая статья содержит индетификатор 1, вторая 2 итд
    id = db.Column(db.Integer, primary_key=True)  #создавая поле (переменную) мы обращаемся к db используя .Column именно через .Column мы создаем определенное поле в таблички и передаем в .Column параметры, в котором мы говорим какое поле мы создаем, то есть это поле которое может содержать только числа  или только строки или какие то другие дополнительные параметры можно указать, например что это поле содержит только строки и длтна этой строки максимум 300 символов. поскольку это id то есть некое число, мы указываем тип db.Integer, обращаясь к db, также необходимо дополнительно указать primary_key=True оно позволяет указать что это поле должно быть уникальным, то есть не должно быть двух полей с одинаковым значением id
    title = db.Column(db.String(100), nullable=False)
    intro = db.Column(db.String(300), nullable=False)  #нельзя установить пустое значение : nullable=False
    text = db.Column(db.Text, nullable=False)  #тип данных Text потому что статья может содержать огромное количество символов
    date = db.Column(db.DateTime, default=datetime.utcnow)  #устанавливаем дату публикации, default=datetime.utcnow указывает значение по умолчанию, если в ручную не указали дату публикации, то будет подставлятся значение по умолчанию и это значение будет тем временим, в которое была создана наша статья

    def __repr__(self):  # магический метод __repr__ при помощи которого указывается, что когда мы будем выбирать какаой либо объект на основе класса Article, то нам будет выдаваться сам этот объект который представляет из себя определенную запись в базе данных
        return '<Article %r>' % self.id  # возвращаем сам объект (определенную запись в базе данных) и его id


with app.app_context():
    db.create_all()


#построим функцию, которая будет отслеживать определенный url адресс и в зависимости от определенного url адреса мы будем показывать пользователю какую либо информацию
@app.route('/')  #создаем декоратор, обращаясь к app используя функцию route, аргументом которой является url адрес, для главной (начальной) страницы нужно указать просто /
@app.route('/home')  #если мы хотим чтобы одна функция обрабатывала сразу несколько url адресов без добавления одинаковых участков кода, мы можем просто добавить декоратор с новым url адресом, теперь две странички с разными адресами  выполняют одинаковые функции
def index():  #создаем функцию, которая возвращает заданный параметр при переходе на страницу с данным url адресом
    return render_template("index.html")  # возвращаем html файл, но можно возвращать просто текст


@app.route('/about')
def about():
    return render_template("about.html")


@app.route('/user/<string:name>/<int:id>')  #если мы хотим получить некий парметр из url адреса путем ввода в адресной строке данного параметра. необходимо указать тип параметров
def user(name, id):  #данные параметры необходимо принимать в самой функции
    return "User page" + name + " - " + str(id)  #приводим данные к одному типу, в данном случае string


@app.route('/create-article', methods=['POST', 'GET']) #Изначально фуекции срабатывают только на get запросы (на переходы на странички), но чтобы нам указать, что функция должна обрабатыват данные по методу POST. Для этого указываем methods=['POST', 'GET'] и это спмсок из тех методов, которые мы можем принимать, то есть теперь эта функция может обрабатывать данные из формы и ппросто переход на эту страничку
def create_article():
    if request.method == 'POST':  #мы проверяем какой метод передачи данных сейчас осуществлен, если POST, то мы должны принять данные из форм, обработать и добавить в базу данных
        title = request.form['title']
        intro = request.form['intro']
        text = request.form['text']

        article = Article(title=title, intro=intro, text=text)  #получив все данные нам необходимо эти данные передать в объект, который будет создан на основе класса Article и далее этот созданный объект нужно будет просто сохранить в базе данных, поэтому создаем конструктор и передаем туда наши значения
        try:  # после создания объекта (конструктора) нам необходимо его сохранить в базе данных, но для начала пропишем конструкцию try-except, потому что когда мы работаем с базами данныхт, то иогут возникать ошибки и мы их должны обрабатывать
            db.session.add(article)  #при помощи функции app() мы добавляем объект
            db.session.commit()  #при помощи функции commit() мы этот объект уже сохраняем
            return redirect('/posts')  # если у нас успешное добавление новой статьи, то мы пользователя переадресовываем на главную страницу с помощью функции redirect()
        except:
            return "При добавлении статьи произошла ошибка"
    else:  # Если не метод POST, то значит у нас метод GET и тогда мы должны просто отобразить пользователю шаблон html
        return render_template("create-article.html")


@app.route('/posts')
def posts():
    articles = Article.query.order_by(Article.date.desc()).all()  #query зто метод который позволяет обратиться через определенную модель (класс) к базе данных, метод first позволяет обратиться к первой табличке из базы данных, для вывода всех табличек из базы данных необходимо использовать метод all, order_by позволяет указать по какому полю мы будем сортировать полученные данные, в данном случае по полю date (по дате публикации), desc() эта функция гоаорит что сортировка идет в формате спадания (в обратном порядке)
    return render_template("posts.html", articles=articles)  #articles=articles необходима для передачи списка в шаблон, при этом в шаблоне мы можем иметь доступ к списку по названию, то есть просто в шаблон передаем список всех наших записей и в шаблоне мы можем работать с этим списком по ключевому слову articles


@app.route('/posts/<int:id>')  #для обработки нужного url адреса
def post_detail(id):
    article = Article.query.get(id)
    return render_template("post_detail.html", article=article)


@app.route('/posts/<int:id>/delete')  #для удаления записи
def post_delete(id):
    article = Article.query.get_or_404(id)  # get_or_404 эта фуекция делает то что и get, но есл у нас не будет найдена запись по определенному id, то в таком случае будет вызываться ошибка 404
    try:
        db.session.delete(article)
        db.session.commit()
        return redirect('/posts')
    except:
        return "При удалении статьи произошла ошибка"


@app.route('/posts/<int:id>/update', methods=['POST', 'GET'])
def post_update(id):
    article = Article.query.get(id)  # для поиска определенной статьи
    if request.method == 'POST':
        article.title = request.form['title']
        article.intro = request.form['intro']
        article.text = request.form['text']
        try:
            db.session.commit() #сохранени, а вданном случае обновление
            return redirect('/posts')
        except:
            return "При редактировании статьи произошла ошибка"
    else:
        return render_template("post_update.html", article=article)


if __name__ == "__main__":  #для работы и вывода программы нам необходимо проверить условие, что если файл app.py является главным (если мы через него запускаем), то мы должны запускать проект как flask приложение. когда мы будем запускать приложение, то в __name__ поместится значение __main__
    app.run(debug=True)  #команда run() позволит запустить локальный сервер, по сути позволит запустить сам flask проект, еще добавим один параметр (debug=True), таким образом все различные ошибки будут выводится на страничках сайта, пока идет разработка это просто для удобства, после окончания разработки стоит убрать